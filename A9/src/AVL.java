/**
 * @author Maureen Lynch
 * @version 1.0
 * @date Fall 2020
 */

//-----------------------------------------------------------------------
// Empty AVL exception

class EmptyAVLE extends Exception {
}

//-----------------------------------------------------------------------
// Abstract AVL class

abstract class AVL<E extends Comparable<E>> implements TreePrinter.PrintableNode {

    //--------------------------
    // Static fields and methods
    //--------------------------

    static EmptyAVLE EAVLX = new EmptyAVLE();

    //--------------------------
    // Getters and simple methods
    //--------------------------

    abstract E AVLData() throws EmptyAVLE;

    abstract AVL<E> AVLLeft() throws EmptyAVLE;

    abstract AVL<E> AVLRight() throws EmptyAVLE;

    abstract boolean isEmpty();

    abstract int AVLHeight();

    //--------------------------
    // Main methods
    //--------------------------

    abstract boolean AVLfind(E key);

    abstract AVL<E> AVLinsert(E key);

    abstract AVL<E> AVLeasyRight();

    abstract AVL<E> AVLrotateRight();

    abstract AVL<E> AVLeasyLeft();

    abstract AVL<E> AVLrotateLeft();

    /**
     * Four new methods to convert an AVL tree to a red-black one. The
     * main idea of the algorithm we will use can be captured by the
     * following invariants:
     *
     * An AVL tree of height 2n can be converted to a red tree
     *   with black height n. This is what method colorRed() should do.
     *
     * An AVL tree of height 2n can be converted to a black tree
     *   with black height (n+1). This is what method colorBlackEven
     *   should do.
     *
     * An AVL tree of height 2n+1 can be converted to a black tree
     *   with black height (n+1). This is what method colorBlackOdd
     *   should do.
     *
     * The entry point for these methods is the method toRB(). Since
     * the root should be colored black, it calls colorBlackEven or
     * colorBlackOdd depending on whether the current AVL tree has
     * even height or odd height.
     *
     */

    abstract RedBlackT<E> toRB ();

    /**
     * When this method is called, it creates a black node whose
     * colors are calculated as follows:
     *   - if the current AVL tree has children of equal height,
     *     then the generated nodes are red
     *   - if the current AVL tree has children that differ in
     *     height, then the generated node for the shorter tree
     *     is black and the other is red
     */
    abstract RedBlackT<E> colorBlackOdd ();

    /**
     * When this method is called, it creates a black node whose children
     * will also be black. The children are generated by either colorBlackEven
     * or colorBlackOdd depending on whether the height of the AVL child
     * is even or odd.
     */
    abstract RedBlackT<E> colorBlackEven ();

    /**
     * When this method is called, it creates a red node whose children
     * must be black. The children are generated by either colorBlackEven
     * or colorBlackOdd depending on whether the height of the AVL child
     * is even or odd.
     */
    abstract RedBlackT<E> colorRed  ();
}

//-----------------------------------------------------------------------

class EmptyAVL<E extends Comparable<E>> extends AVL<E> {

    //--------------------------
    // Getters and simple methods
    //--------------------------

    E AVLData() throws EmptyAVLE {
        throw EAVLX;
    }

    AVL<E> AVLLeft() throws EmptyAVLE {
        throw EAVLX;
    }

    AVL<E> AVLRight() throws EmptyAVLE {
        throw EAVLX;
    }

    boolean isEmpty() {
        return true;
    }

    // We are changing our convention for the height of an empty tree
    // This will make it easier to state the invariant needed to
    // convert to a red-black tree
    int AVLHeight() {
        return 1;
    }

    //--------------------------
    // Main methods
    // Adapting the methods from before to this generic class
    //--------------------------

    boolean AVLfind(E key) {
        return false;
    }

    AVL<E> AVLinsert(E key) {
        return new AVLNode<>(key, new EmptyAVL<>(), new EmptyAVL<>());
    }

    AVL<E> AVLeasyRight() {
        throw new Error("Internal bug: should never call easyRight on empty tree");
    }

    AVL<E> AVLrotateRight() {
        throw new Error("Internal bug: should never call rotateRight on empty tree");
    }

    AVL<E> AVLeasyLeft() {
        throw new Error("Internal bug: should never call easyLeft on empty tree");
    }

    AVL<E> AVLrotateLeft() {
        throw new Error("Internal bug: should never call rotateLeft on empty tree");
    }

    RedBlackT<E> toRB () {
        return this.colorBlackOdd();
    }

    RedBlackT<E> colorBlackEven () {
        throw new Error();
    }

    RedBlackT<E> colorBlackOdd () {
        return new EmptyRB<>();
    }

    RedBlackT<E> colorRed  () {
       throw new Error();
    }

    //--------------------------
    // Override
    //--------------------------

    public boolean equals(Object o) {
        return (o instanceof EmptyAVL);
    }

    //--------------------------
    // Printable interface
    //--------------------------

    public TreePrinter.PrintableNode getLeft() {
        return null;
    }

    public TreePrinter.PrintableNode getRight() {
        return null;
    }

    public String getText() {
        return "";
    }
}

//-----------------------------------------------------------------------

class AVLNode<E extends Comparable<E>> extends AVL<E> {
    private final E data;
    private final AVL<E> left;
    private final AVL<E> right;
    private final int height;

    AVLNode(E data, AVL<E> left, AVL<E> right) {
        this.data = data;
        this.left = left;
        this.right = right;
        this.height = 1 + Math.max(left.AVLHeight(), right.AVLHeight());
    }

    //--------------------------
    // Getters and simple methods
    //--------------------------

    E AVLData() {
        return data;
    }

    AVL<E> AVLLeft() {
        return left;
    }

    AVL<E> AVLRight() {
        return right;
    }

    boolean isEmpty() {
        return false;
    }

    int AVLHeight() {
        return height;
    }

    //--------------------------
    // Main methods
    // Adapt methods from before to this generic class
    //--------------------------

    boolean AVLfind(E key) {
        return this.AVLData().equals(key) || this.AVLLeft().AVLfind(key) || this.AVLRight().AVLfind(key);
    }

    AVL<E> AVLinsert(E key) {
        try {
            AVL insertTree;
            if (key.compareTo(this.AVLData()) < 0) {
                insertTree = new AVLNode(this.AVLData(), this.AVLLeft().AVLinsert(key), this.AVLRight());
                if (Math.abs(insertTree.AVLLeft().AVLHeight() - insertTree.AVLRight().AVLHeight()) > 1) {
                    return insertTree.AVLrotateRight();
                }
                else{ return insertTree;}
            }
            else {
                insertTree = new AVLNode(this.AVLData(), this.AVLLeft(), this.AVLRight().AVLinsert(key));
                if (Math.abs(insertTree.AVLLeft().AVLHeight() - insertTree.AVLRight().AVLHeight()) > 1) {
                    return insertTree.AVLrotateLeft();
                }
                else{ return insertTree;}
            }
        }
        catch(EmptyAVLE emptyAVLE){
            return new EmptyAVL();
        }
    }

    AVL<E> AVLeasyRight() {
        AVL nextTree = this;
        try {
            AVL newRight = new AVLNode(this.AVLData(), this.AVLLeft().AVLRight(), this.AVLRight());
            nextTree = new AVLNode(this.AVLLeft().AVLData(), this.AVLLeft().AVLLeft(), newRight);
        }
        catch (EmptyAVLE emptyAVLE) {
            emptyAVLE.printStackTrace();
        }
        return nextTree;
    }

    AVL<E> AVLrotateRight() {
        try {
            if (this.AVLLeft().AVLLeft().AVLHeight() < this.AVLLeft().AVLRight().AVLHeight()) {
                AVL newLeft = this.AVLLeft().AVLeasyLeft();
                AVL newOriginal = new AVLNode(this.AVLData(), newLeft, this.AVLRight());
                return newOriginal.AVLeasyRight();
            }
            else { return this.AVLeasyRight(); }
        }
        catch (EmptyAVLE emptyAVLE) {
            return new EmptyAVL();
        }
    }

    AVL<E> AVLeasyLeft() {
        AVL nextTree = this;
        try {
            AVL newLeft = new AVLNode(this.AVLData(), this.AVLLeft(), this.AVLRight().AVLLeft());
            nextTree = new AVLNode(this.AVLRight().AVLData(), newLeft, this.AVLRight().AVLRight());
        }
        catch (EmptyAVLE emptyAVLE) {
            emptyAVLE.printStackTrace();
        }
        return nextTree;
    }

    AVL<E> AVLrotateLeft() {
        try {
            if (this.AVLRight().AVLRight().AVLHeight() < this.AVLRight().AVLLeft().AVLHeight()) {
                AVL newRight = this.AVLRight().AVLeasyRight();
                AVL newOriginal = new AVLNode(this.AVLData(), this.AVLLeft(), newRight);
                return newOriginal.AVLeasyLeft();
            }
            else { return this.AVLeasyLeft(); }
        }
        catch(EmptyAVLE emptyAVLE){
            return new EmptyAVL();
        }
    }

    RedBlackT<E> toRB () {
        if(this.AVLHeight() % 2 == 0){
            return this.colorBlackEven();
        }
        else{
            return this.colorBlackOdd();
        }
    }

    RedBlackT<E> colorBlackEven () {
        RedBlackT<E> leftChild = new EmptyRB<>();
        RedBlackT<E> rightChild = new EmptyRB<>();

        if(this.AVLLeft().AVLHeight() % 2 == 0){ leftChild = this.AVLLeft().colorBlackEven(); }
        else if(this.AVLLeft().AVLHeight() % 2 != 0){ leftChild = this.AVLLeft().colorBlackOdd(); }

        if(this.AVLRight().AVLHeight() % 2 == 0){ rightChild = this.AVLRight().colorBlackEven(); }
        else if(this.AVLRight().AVLHeight() % 2 != 0){ rightChild = this.AVLRight().colorBlackOdd(); }

        return new RBNode<>(this.AVLData(), Color.BLACK, leftChild, rightChild);
    }

    RedBlackT<E> colorBlackOdd () {
        RedBlackT<E> leftChild = new EmptyRB<>();
        RedBlackT<E> rightChild = new EmptyRB<>();

        if(this.AVLLeft().AVLHeight() < this.AVLRight().AVLHeight()){
         //   if(this.AVLLeft().AVLHeight() % 2 == 0){ leftChild = this.AVLLeft().colorBlackEven(); }
         //   else if(this.AVLLeft().AVLHeight() % 2 != 0){
            leftChild = this.AVLLeft().colorBlackOdd();
            rightChild = this.AVLRight().colorRed();
        }
        else if(this.AVLLeft().AVLHeight() == this.AVLRight().AVLHeight()){
            leftChild = this.AVLLeft().colorRed();
            rightChild = this.AVLRight().colorRed();
        }
        else{
            leftChild = this.AVLLeft().colorRed();
           // if(this.AVLRight().AVLHeight() % 2 == 0){ rightChild = this.AVLRight().colorBlackEven(); }
           // else if(this.AVLRight().AVLHeight() % 2 != 0){
            rightChild = this.AVLRight().colorBlackOdd();
        }
        return new RBNode<>(this.AVLData(), Color.BLACK, leftChild, rightChild);
    }

    RedBlackT<E> colorRed  () {
        RedBlackT<E> leftChild = new EmptyRB<>();
        RedBlackT<E> rightChild = new EmptyRB<>();

        if(this.AVLLeft().AVLHeight() % 2 == 0){ leftChild = this.AVLLeft().colorBlackEven(); }
        else if(this.AVLLeft().AVLHeight() % 2 != 0){ leftChild = this.AVLLeft().colorBlackOdd(); }

        if(this.AVLRight().AVLHeight() % 2 == 0){ rightChild = this.AVLRight().colorBlackEven(); }
        else if(this.AVLRight().AVLHeight() % 2 != 0){ rightChild = this.AVLRight().colorBlackOdd(); }

        return new RBNode<>(this.AVLData(), Color.RED, leftChild, rightChild);
    }

    //--------------------------
    // Override
    //--------------------------

    public boolean equals(Object o) {
        if (o instanceof AVLNode) {
            AVLNode other = (AVLNode) o;
            return data == other.data && left.equals(other.left) && right.equals(other.right);
        }
        return false;
    }

    //--------------------------
    // Printable interface
    //--------------------------

    public TreePrinter.PrintableNode getLeft() {
        return left.isEmpty() ? null : left;
    }

    public TreePrinter.PrintableNode getRight() {
        return right.isEmpty() ? null : right;
    }

    public String getText() {
        return String.valueOf(data);
    }
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
